{"componentChunkName":"component---src-templates-question-js","path":"/question/797_all-paths-from-source-to-target.md","result":{"data":{"site":{"siteMetadata":{"title":"Leetcode Collection"}},"markdownRemark":{"html":"<h2>Problem</h2>\n<p>Given a directed&nbsp;acyclic graph (<strong>DAG</strong>) of <code>n</code> nodes labeled from 0 to n - 1,&nbsp;find all possible paths from node <code>0</code> to node <code>n - 1</code>, and return them in any order.</p>\n<p>The graph is given as follows:&nbsp;<code>graph[i]</code> is a list of all nodes you can visit from node <code>i</code>&nbsp;(i.e., there is a directed edge from node <code>i</code> to node <code>graph[i][j]</code>).</p>\n<p>&#xA0;</p>\n<p><strong>Example 1:</strong></p>\n<img alt src=\"https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg\" style=\"width: 242px; height: 242px;\">\n<pre><strong>Input:</strong> graph = [[1,2],[3],[3],[]]\n<strong>Output:</strong> [[0,1,3],[0,2,3]]\n<strong>Explanation:</strong> There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.\n</pre>\n<p><strong>Example 2:</strong></p>\n<img alt src=\"https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg\" style=\"width: 423px; height: 301px;\">\n<pre><strong>Input:</strong> graph = [[4,3,1],[3,2,4],[3],[4],[]]\n<strong>Output:</strong> [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n</pre>\n<p><strong>Example 3:</strong></p>\n<pre>\n<strong>Input:</strong> graph = [[1],[]]\n<strong>Output:</strong> [[0,1]]\n</pre>\n<p><strong>Example 4:</strong></p>\n<pre>\n<strong>Input:</strong> graph = [[1,2,3],[2],[3],[]]\n<strong>Output:</strong> [[0,1,2,3],[0,2,3],[0,3]]\n</pre>\n<p><strong>Example 5:</strong></p>\n<pre>\n<strong>Input:</strong> graph = [[1,3],[2],[3],[]]\n<strong>Output:</strong> [[0,1,2,3],[0,3]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt; n</code></li>\n\t<li><code>graph[i][j] != i</code> (i.e., there will be no self-loops).</li>\n\t<li>The input graph is <strong>guaranteed</strong> to be a <strong>DAG</strong>.</li>\n</ul>\n<h2>Discussion</h2>\n<p>We can interpret this question as searching on graph, finding paths from the\nsame source node to the same target node. With different format of graphs,\nthis problem is providing graph based on <code>Adjacency List</code>. DFS should\nbe a good solution for this problem.</p>\n<h3>Solution</h3>\n<p>We perform DFS on the starting node <code>0</code>, and search for all on-going edges down\nto the end node <code>graph.length - 1</code>. And as the graph is given as acyclic, there\nis no validation required on the paths. As long as the paths converges at the\nend node. We include the path into our result.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> List\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">allPathsSourceTarget</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> graph<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>graph <span class=\"token operator\">=</span> graph\n        self<span class=\"token punctuation\">.</span>result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        start <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n        path <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n        self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>result\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> next_nodes<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> next_nodes<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> node <span class=\"token keyword\">in</span> next_nodes<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> node <span class=\"token operator\">==</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>graph<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                    self<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>path <span class=\"token operator\">+</span> <span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                    self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>graph<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> path <span class=\"token operator\">+</span> <span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Complexity Analysis</h3>\n<ul>\n<li>Time Complexity: <code>O(V + E)</code>, for DFS in a graph, wheres <code>V</code> is number of nodes\nand <code>E</code> is the number of edges.</li>\n<li>Space Complexity: <code>O(V * E)</code>, for the result set in memory, which the number\nis determined by the number of edges, while the size is determined by the\nnumber of vertex.</li>\n</ul>","frontmatter":{"id":797,"title":"All Paths From Source to Target","url":"https://leetcode.com/problems/all-paths-from-source-to-target/description/","tags":["backtracking","depth-first-search","graph"],"difficulty":"Medium","acceptance":"78.1%"}}},"pageContext":{"id":797}},"staticQueryHashes":["72776548"]}