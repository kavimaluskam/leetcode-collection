{"componentChunkName":"component---src-templates-question-js","path":"/question/100_same-tree.md","result":{"data":{"site":{"siteMetadata":{"title":"Leetcode Collection"}},"markdownRemark":{"html":"<h2>Problem</h2>\n<p>Given two binary trees, write a function to check if they are the same or not.</p>\n<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>\n<p><strong>Example 1:</strong></p>\n<pre>\n<strong>Input:</strong>     1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n<strong>Output:</strong> true\n</pre>\n<p><strong>Example 2:</strong></p>\n<pre>\n<strong>Input:</strong>     1         1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n<strong>Output:</strong> false\n</pre>\n<p><strong>Example 3:</strong></p>\n<pre>\n<strong>Input:</strong>     1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n<strong>Output:</strong> false\n</pre>\n<h2>Discussion</h2>\n<p>A DFS algorithm would be able to scan down both tree at the same time, and\npointing out difference when spotted.</p>\n<h3>Solution</h3>\n<p>A simple DFS algorithm on both tree would works.\nNote that after we compare the value for both nodes, passing child node to\nrecursion is sufficient enough for scanning.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Definition for a binary tree node.</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> val<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> left<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> val\n        self<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> left\n        self<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> right\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">isSameTree</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">:</span> TreeNode<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">:</span> TreeNode<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> p <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> q<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> p <span class=\"token keyword\">or</span> <span class=\"token keyword\">not</span> q<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n        <span class=\"token keyword\">if</span> p<span class=\"token punctuation\">.</span>val <span class=\"token operator\">!=</span> q<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>isSameTree<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> \\\n            self<span class=\"token punctuation\">.</span>isSameTree<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Complexity Analysis</h3>\n<ul>\n<li>Time Complexity: <code>O(n)</code>, for simple DFS scanning the whole tree</li>\n<li>Space Complexity:  <code>O(n)</code>, for simple DFS holding all nodes in recursion.\nNote that for perfect balanced binary tree, space complexity would be just\n<code>O(log(n))</code> as the depth of the tree would be <code>log(n)</code>.</li>\n</ul>","frontmatter":{"id":100,"title":"Same Tree","url":"https://leetcode.com/problems/same-tree/description/","tags":["tree","depth-first-search"],"difficulty":"Easy","acceptance":"53.7%"}}},"pageContext":{"id":100}},"staticQueryHashes":["3111183354"]}