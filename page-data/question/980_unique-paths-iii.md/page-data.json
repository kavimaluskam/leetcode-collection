{"componentChunkName":"component---src-templates-question-js","path":"/question/980_unique-paths-iii.md","result":{"data":{"site":{"siteMetadata":{"title":"Leetcode Collection"}},"markdownRemark":{"html":"<h2>Problem</h2>\n<p>On a 2-dimensional&nbsp;<code>grid</code>, there are 4 types of squares:</p>\n<ul>\n\t<li><code>1</code> represents the starting square.&nbsp; There is exactly one starting square.</li>\n\t<li><code>2</code> represents the ending square.&nbsp; There is exactly one ending square.</li>\n\t<li><code>0</code> represents empty squares we can walk over.</li>\n\t<li><code>-1</code> represents obstacles that we cannot walk over.</li>\n</ul>\n<p>Return the number of 4-directional walks&nbsp;from the starting square to the ending square, that <strong>walk over every non-obstacle square&nbsp;exactly once</strong>.</p>\n<p>&nbsp;</p>\n<div>\n<p><strong>Example 1:</strong></p>\n<pre>\n<strong>Input: </strong><span id=\"example-input-1-1\">[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</span>\n<strong>Output: </strong><span id=\"example-output-1\">2</span>\n<strong>Explanation: </strong>We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</pre>\n<div>\n<p><strong>Example 2:</strong></p>\n<pre>\n<strong>Input: </strong><span id=\"example-input-2-1\">[[1,0,0,0],[0,0,0,0],[0,0,0,2]]</span>\n<strong>Output: </strong><span id=\"example-output-2\">4</span>\n<strong>Explanation: </strong>We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</pre>\n<div>\n<p><strong>Example 3:</strong></p>\n<pre>\n<strong>Input: </strong><span id=\"example-input-3-1\">[[0,1],[2,0]]</span>\n<strong>Output: </strong><span id=\"example-output-3\">0</span>\n<strong>Explanation: </strong>\nThere is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n</pre>\n</div>\n</div>\n</div>\n<p>&nbsp;</p>\n<p><strong>Note:</strong></p>\n<ol>\n\t<li><code>1 &lt;= grid.length * grid[0].length &lt;= 20</code></li>\n</ol>\n<h2>Discussion</h2>\n<p>This problem requires us to find all unique paths from point <code>1</code> to <code>2</code>.</p>\n<p>As this requires iterations through all elements and all paths between two\npoints, we may come up with the idea of using DFS. Things become straight\nforward now as actually this problem is very similar to\n<a href=\"../79_word-search\">79. Word Search</a>, which is obvious a DFS and back-tracking\nproblem.</p>\n<p>Besides DFS and back-tracking to find all unique paths, we also have to make\nsure all <code>0</code> is being used exactly once in the paths, and no other values\nbesides <code>0</code> and <code>1</code> are used. Achieving this we simply count all the <code>0</code> in grid\nand do validation.</p>\n<h3>Solution</h3>\n<p>We begin our solution with a loop finding all the <code>0</code> in the grid, and scanning\n<code>1</code> to begin our DFS method. We use DFS by recursion here for simplicity.</p>\n<p>In the DFS, we temporary update the visited node to some special value (<code>999</code>)\nto prevent re-use of the same element in the grid and we restore the value after\neach iteration.</p>\n<p>Besides we maintain a variable <code>step</code> to see how many <code>0</code> or <code>1</code> is visited.\nWhen we reach <code>2</code>, we check the value of <code>step</code> to see if all <code>0</code>\nare being passed through exactly once. Then we update our result number if\na new unique path is founded.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> List\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">uniquePathsIII</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> grid<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>grid <span class=\"token operator\">=</span> grid\n        self<span class=\"token punctuation\">.</span>result <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        self<span class=\"token punctuation\">.</span>number_of_zero <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>grid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                    self<span class=\"token punctuation\">.</span>number_of_zero <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>grid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                    self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>result\n\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> step<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> step <span class=\"token operator\">==</span> self<span class=\"token punctuation\">.</span>number_of_zero <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                self<span class=\"token punctuation\">.</span>result <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">return</span>\n\n\n        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            temp<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">999</span>\n\n            <span class=\"token keyword\">if</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> step <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n            <span class=\"token keyword\">if</span> j <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> step <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n            <span class=\"token keyword\">if</span> i <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>grid<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> step <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n            <span class=\"token keyword\">if</span> j <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>grid<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> step <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n            self<span class=\"token punctuation\">.</span>grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp\n\n        <span class=\"token keyword\">return</span></code></pre></div>\n<h3>Complexity Analysis</h3>\n<ul>\n<li>Time Complexity: <code>O(3^n)</code>, as although we have 4 directions go search in each\niteration, we have at most 3 directions to go in each iteration.</li>\n<li>Space Complexity: <code>O(n)</code>, as we apply recursion which at most holding <code>n</code>\nlayer of instances. Besides only the input grid and other constant variables\nare maintained in memory.</li>\n</ul>","frontmatter":{"id":980,"title":"Unique Paths III","url":"https://leetcode.com/problems/unique-paths-iii/description/","tags":["backtracking","depth-first-search"],"difficulty":"Hard","acceptance":"76.9%"}}},"pageContext":{"id":980}},"staticQueryHashes":["3111183354"]}