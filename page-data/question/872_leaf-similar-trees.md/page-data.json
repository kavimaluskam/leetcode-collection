{"componentChunkName":"component---src-templates-question-js","path":"/question/872_leaf-similar-trees.md","result":{"data":{"site":{"siteMetadata":{"title":"Leetcode Collection"}},"markdownRemark":{"html":"<h2>Problem</h2>\n<p>Consider all the leaves of a binary tree, from&nbsp;left to right order, the values of those&nbsp;leaves form a <strong>leaf value sequence</strong><em>.</em></p>\n<p><img alt src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png\" style=\"width: 400px; height: 336px;\"></p>\n<p>For example, in the given tree above, the leaf value sequence is <code>(6, 7, 4, 9, 8)</code>.</p>\n<p>Two binary trees are considered <em>leaf-similar</em>&nbsp;if their leaf value sequence is the same.</p>\n<p>Return <code>true</code> if and only if the two given trees with head nodes <code>root1</code> and <code>root2</code> are leaf-similar.</p>\n<p>&#xA0;</p>\n<p><strong>Example 1:</strong></p>\n<img alt src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg\" style=\"width: 750px; height: 297px;\">\n<pre><strong>Input:</strong> root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n<strong>Output:</strong> true\n</pre>\n<p><strong>Example 2:</strong></p>\n<pre>\n<strong>Input:</strong> root1 = [1], root2 = [1]\n<strong>Output:</strong> true\n</pre>\n<p><strong>Example 3:</strong></p>\n<pre>\n<strong>Input:</strong> root1 = [1], root2 = [2]\n<strong>Output:</strong> false\n</pre>\n<p><strong>Example 4:</strong></p>\n<pre>\n<strong>Input:</strong> root1 = [1,2], root2 = [2,2]\n<strong>Output:</strong> true\n</pre>\n<p><strong>Example 5:</strong></p>\n<img alt src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg\" style=\"width: 450px; height: 165px;\">\n<pre><strong>Input:</strong> root1 = [1,2,3], root2 = [1,3,2]\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n<ul>\n\t<li>The number of nodes in each tree will be in the range <code>[1, 200]</code>.</li>\n\t<li>Both of the given trees will have values in the range <code>[0, 200]</code>.</li>\n</ul>\n<h2>Discussion</h2>\n<p>The problem requires us to find compare two trees with the sequence\nof their leaf nodes. As the leaf nodes may not by lying on the same level,\nwe are going to use DFS to scan for the leaf nodes as array and perform\ncomparison.</p>\n<h3>Solution</h3>\n<p>Our solution starts with writing an standard DFS function\nto scan for leaf nodes. Leaf nodes are then appended to target array.\nA complete DFS function should scan all the leaf nodes and put them to\nan array with maintained sequence.</p>\n<p>We simply compare the two array and result is obtained.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">leafSimilar</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> root1<span class=\"token punctuation\">:</span> TreeNode<span class=\"token punctuation\">,</span> root2<span class=\"token punctuation\">:</span> TreeNode<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n        self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>root1<span class=\"token punctuation\">)</span>\n        arr1<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>arr <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>arr<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n        self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>root2<span class=\"token punctuation\">)</span>\n        arr2<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>arr <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>arr<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n        <span class=\"token keyword\">return</span> arr1 <span class=\"token operator\">==</span> arr2\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> root<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token keyword\">if</span> root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> root<span class=\"token punctuation\">.</span>left <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>arr <span class=\"token operator\">+=</span> <span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">if</span> root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>dfs<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Complexity Analysis</h3>\n<ul>\n<li>Time Complexity: <code>O(n)</code>, as DFS scan all the nodes in a tree and giving a\nlinear time complexity. Perform it twice gives an linear solution as well.</li>\n<li>Space Complexity: <code>O(n)</code>, regardless of the deep recursion memory for DFS,\nwe are caching all the leaf nodes in a array, which causing linear\nspace complexity already.</li>\n</ul>","frontmatter":{"id":872,"title":"Leaf-Similar Trees","url":"https://leetcode.com/problems/leaf-similar-trees/description/","tags":["tree","depth-first-search"],"difficulty":"Easy","acceptance":"64.5%"}}},"pageContext":{"id":872}},"staticQueryHashes":["72776548"]}