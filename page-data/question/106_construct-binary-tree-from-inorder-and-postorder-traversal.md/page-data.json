{"componentChunkName":"component---src-templates-question-js","path":"/question/106_construct-binary-tree-from-inorder-and-postorder-traversal.md","result":{"data":{"site":{"siteMetadata":{"title":"Leetcode Collection"}},"markdownRemark":{"html":"<h2>Problem</h2>\n<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>\n<p><strong>Note:</strong><br />\nYou may assume that duplicates do not exist in the tree.</p>\n<p>For example, given</p>\n<pre>\ninorder =&nbsp;[9,3,15,20,7]\npostorder = [9,15,7,20,3]</pre>\n<p>Return the following binary tree:</p>\n<pre>\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n<h2>Discussion</h2>\n<p>First of all, we clarify that <code>in-order traversal</code> and <code>post-order traversal</code>\ndisplay binary trees as:</p>\n<ul>\n<li>in-order traversal: [<code>...left</code>, <code>root</code>, <code>...right</code>]</li>\n<li>post-order traversal: [<code>...left</code>, <code>...right</code>, <code>root</code>]</li>\n</ul>\n<p>Hence we have to come up with algorithm reading the tree structure\nbased on these two traversal's ordering.</p>\n<p>Besides, we can imagine that recursive algorithm is more\nstraight forward for tree construction problems.</p>\n<p>Our solution will go with the above two ideas.\nWe would start with a rather straight forward algorithm and\nsee if any enhancement can be made.</p>\n<h3>Trial 1</h3>\n<p><em>Trial 1</em> gives a straight forward implementation based on\nbreaking down the in-order and post-order traversal.</p>\n<p>Considering the example input:</p>\n<ul>\n<li>in-order: <code>[9, 3, 15, 20, 7]</code></li>\n<li>post-order: <code>[9, 15, 7, 20, 3]</code></li>\n</ul>\n<p>As stated above, the root element of the current subtree can always be found\nin the end the of the post-order traversal.</p>\n<p>Hence we can use the element to break down the in-order traversal into:\n<code>left</code>, <code>root</code> and <code>right</code> component.</p>\n<p>Then as the in-order and post-order traversal of the same sub-tree must be of\nsame length, we can find the three component by the length of the components\nin in-order traversal.</p>\n<p>After breaking down both traversal, we can construct the tree recursively as:\n<code>build(left) - root - build(right)</code></p>\n<p>The time complexity of this trial would be <code>O(n^2)</code>. As considering a binary\ntree with all sub-trees on left side, we have to search the whole\nin-order traversal with size <code>(n-i)</code> with every i-th iteration, which gives\niteration of <code>n * (n + 1) / 2</code> = <code>O(n^2)</code>.</p>\n<p>The space complexity of this trial would be <code>O(n^2)</code> as well. Considering\nthe same binary tree with all sub-trees on left side, we construct the tree\nrecursively and pass the trimmed left traversals and right traversals to the\nnext level. Here the order of recursion is at most <code>n</code>,\nand traversals' length is also limited at <code>n</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> List\n\n<span class=\"token comment\"># Definition for a binary tree node.</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> val<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> left<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> val\n        self<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> left\n        self<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> right\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">buildTree</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> inorder<span class=\"token punctuation\">,</span> postorder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> inorder<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span>\n\n        root_value <span class=\"token operator\">=</span> postorder<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        root_node <span class=\"token operator\">=</span> TreeNode<span class=\"token punctuation\">(</span>root_value<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>inorder<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> root_node\n\n        break_ptr <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>inorder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> inorder<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> root_value<span class=\"token punctuation\">:</span>\n                break_ptr <span class=\"token operator\">=</span> i\n\n        root_node<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>buildTree<span class=\"token punctuation\">(</span>\n            inorder<span class=\"token operator\">=</span>inorder<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>break_ptr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            postorder<span class=\"token operator\">=</span>postorder<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>break_ptr<span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">)</span>\n\n        root_node<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>buildTree<span class=\"token punctuation\">(</span>\n            inorder<span class=\"token operator\">=</span>inorder<span class=\"token punctuation\">[</span>break_ptr<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            postorder<span class=\"token operator\">=</span>postorder<span class=\"token punctuation\">[</span>break_ptr<span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">return</span> root_node</code></pre></div>\n<h3>Solution</h3>\n<p><em>The final solution</em> improves <em>Trial 1</em> by caching the\nmaster in-order traversal as dictionary globally, and the construction function\npass index instead of the whole sub-traversals to the next level. Hence the\niteration at each recursive iteration is improved to a <code>O(1)</code> selection, and\nthe space complexity is also improved.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> List\n\n<span class=\"token comment\"># Definition for a binary tree node.</span>\n<span class=\"token comment\"># class TreeNode:</span>\n<span class=\"token comment\">#     def __init__(self, val=0, left=None, right=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.left = left</span>\n<span class=\"token comment\">#         self.right = right</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">buildTree</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> inorder<span class=\"token punctuation\">,</span> postorder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>postorder <span class=\"token operator\">=</span> postorder\n        self<span class=\"token punctuation\">.</span>inorder_cache <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n            inorder<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>i\n            <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>inorder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>build_tree_by_index<span class=\"token punctuation\">(</span>\n            in_start<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n            in_end<span class=\"token operator\">=</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>inorder<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n            post_start<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n            post_end<span class=\"token operator\">=</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>postorder<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">build_tree_by_index</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> in_start<span class=\"token punctuation\">,</span> in_end<span class=\"token punctuation\">,</span> post_start<span class=\"token punctuation\">,</span> post_end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> in_start <span class=\"token operator\">></span> in_end <span class=\"token keyword\">or</span> post_start <span class=\"token operator\">></span> post_end<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">None</span>\n\n        root_value <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>postorder<span class=\"token punctuation\">[</span>post_end<span class=\"token punctuation\">]</span>\n        root_node <span class=\"token operator\">=</span> TreeNode<span class=\"token punctuation\">(</span>root_value<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> in_end <span class=\"token operator\">==</span> in_start<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> root_node\n\n        root_inorder_index <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>inorder_cache<span class=\"token punctuation\">[</span>root_value<span class=\"token punctuation\">]</span>\n\n        root_node<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>build_tree_by_index<span class=\"token punctuation\">(</span>\n            in_start<span class=\"token operator\">=</span>in_start<span class=\"token punctuation\">,</span>\n            in_end<span class=\"token operator\">=</span>root_inorder_index <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n            post_start<span class=\"token operator\">=</span>post_start<span class=\"token punctuation\">,</span>\n            post_end<span class=\"token operator\">=</span>post_start <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>root_inorder_index <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">-</span> in_start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">)</span>\n\n        root_node<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>build_tree_by_index<span class=\"token punctuation\">(</span>\n            in_start<span class=\"token operator\">=</span>root_inorder_index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n            in_end<span class=\"token operator\">=</span>in_end<span class=\"token punctuation\">,</span>\n            post_start<span class=\"token operator\">=</span>post_start <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>root_inorder_index <span class=\"token operator\">-</span> in_start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            post_end<span class=\"token operator\">=</span>post_end <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">return</span> root_node</code></pre></div>\n<h3>Complexity Analysis</h3>\n<ul>\n<li>Time Complexity: <code>O(n)</code>, as the most time consuming step would be the cache\nmap construction, or the recursion down to the bottom level, which are both\n<code>O(n)</code>.</li>\n<li>Space Complexity: <code>O(n)</code>, as we only maintain the cache in-order traversal\ndictionary in space globally, which is <code>O(n)</code>.\nMore over the order of recursion is also <code>O(n)</code>.</li>\n</ul>","frontmatter":{"id":106,"title":"Construct Binary Tree from Inorder and Postorder Traversal","url":"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/","tags":["array","tree","depth-first-search"],"difficulty":"Medium","acceptance":"48.1%"}}},"pageContext":{"id":106}},"staticQueryHashes":["72776548"]}